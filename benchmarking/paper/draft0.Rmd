---
title: "Microstim: open source hardware for precise electrical stimulation"
author: ""
date: "February 11, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(parallel)
```

```{r loadData, cache=TRUE}

projectDirectory = '/home/x/Desktop/microstim/benchmarking/'
setwd(projectDirectory)

BOM=openxlsx::read.xlsx("../microstim_BOM.xlsx")
sum(BOM$Unit.cost*BOM$Quantity, na.rm=TRUE)

paramMat = read.csv(paste(projectDirectory,"paramMat.csv", sep=''))
colnames(paramMat) = c('mode0','mode1','period','duration','ch0amp0','ch1amp0','dur0', 'ch0amp1','ch1amp1','dur1')

vpau = 20/2^12 # volts per adc unit
fs = 2e6       # sampling rate of measurements


dataFiles = list.files(path=paste(projectDirectory,'data',sep=''), pattern="[.]bin", full.names = TRUE)

# readTestFile = function(i){
#   sapply(dataFiles[i], function(f) {
#     matrix(readBin(f, what='integer', n=1e7, size=2, endian = 'big'),ncol=2,byrow=TRUE)
#   }, simplify='array')
# }


getPulseParams = function(f, thresh=100, fs, vpau){
  
  dat = matrix(readBin(f, what='integer', n=1e7, size=2, endian = 'big'),ncol=2,byrow=TRUE)
  
  apply(dat, 2, function(x) {  
    isPulse = 1.0*(x>thresh | x < -thresh)
    isPulse = mmand::erode(mmand::dilate(isPulse, rep(1,21)),rep(1,21))
    pulseIndices = which(isPulse>0)
    
    pulseStartIndices = pulseIndices[c(1,which(diff(pulseIndices) > 3)+1)]
    pulseEndIndices = pulseIndices[c(which(diff(pulseIndices) > 3), length(pulseIndices))]
    
    isStageHigh = 1.0*(x > thresh)
    isStageLow = 1.0*(x < -thresh)
    
    #plot(x[1:3000], type='l', ylim=c(190,220))
    #points(pulseIndices, x[pulseIndices], cex=0.3, col='red')
    #points(pulseStartIndices, x[pulseStartIndices], cex=1, col='blue')
    #points(pulseEndIndices, x[pulseEndIndices], cex=1, col='orange')

    IPI = diff(pulseStartIndices/fs)
    IPI.summary = summary(IPI)
    IPI.sd = sd(IPI)
    
    PW = (pulseEndIndices-pulseStartIndices)/fs
    PW.summary = summary(PW)
    PW.sd = sd(PW)
    
    sh.median = median(x[which(isStageHigh>0)])*vpau
    sh.sd = sd(x[which(mmand::erode(isStageHigh, rep(1,13))>0)])*vpau
    sl.median = median(x[which(isStageLow>0)])*vpau
    sl.sd = sd(x[which(mmand::erode(isStageLow, rep(1,13))>0)])*vpau
    
    pulseMat = sapply(pulseStartIndices, function(j) x[j+(-100:1000)])
    list(IPI.summary=IPI.summary, IPI.sd=IPI.sd, PW.summary=PW.summary, 
             PW.sd=PW.sd, sh.median=sh.median, sh.sd=sh.sd, 
             sl.median=sl.median, sl.sd=sl.sd, pulseMat=pulseMat)
  })
}

j = which(paramMat$mode0 ==0 & paramMat$mode1==2)

cl = makeCluster(detectCores()-1)
res = parLapply(cl, dataFiles[j], getPulseParams, fs=fs, vpau=vpau)
res = unlist(res, recursive = FALSE)
stopCluster(cl)
```

To benchmark, we varied mode, pulse frequency (from `r round(1e6/max(paramMat$period),2)`Hz to `r round(1e6/min(paramMat$period),2)`kHz), pulse duration (from `r min(paramMat$dur0)` to `r max(paramMat$dur0)` us), and amplitude. We simultaneously recorded from both output channels on a National Instruments PCI-6110 card (12-bit ADC, sampling each channel at 2MHz).

## Microstim is built like so
  - Two independently-controllable output channels, each with both current and voltage output modes
  - Total cost: $`r ceiling(sum(BOM$Unit.cost*BOM$Quantity, na.rm=TRUE))` USD.
  - Output range in current mode: -833uA to +833uA.
  - Pulse width in current mode: down to 50 us.
  - Output range in voltage mode: -12V to 12V.
  - Pulse width in current mode: down to 10 us.
  - In current mode, +-11V compliance voltage (+/-833uA output possible for resistances up to 13k, +-110uA possible for resistances up to 100k)
  - Channels are isolated 
  - Onboard ADC measurement of actual output current or voltage
  - runs on USB power
  - uses a Teensy-based microcontroller
  - FIGURE 1 (picture)

## Microstim is precise

  - amplitude accuracy
    - voltage and current output
  - pulse timing accuracy
  - channels are isolated
  - FIGURE 2 (benchmarks)

```{r benchmarkFigure, fig.height=8,fig.width=8}


par(mar=c(4,5,2,2), mfrow=c(4,3))
plot(sapply(res, function(x) x$IPI.summary[3])*1e6, ylab='Median interpulse interval\n(microsec)', log='y')
abline(h=unique(paramMat$period), col='red')
plot(sapply(res, function(x) x$IPI.sd)*1e6, ylab='Interpulse interval stdev\n(microsec)')
abline(h=0.5)
plot(sapply(res, function(x) diff(x$IPI.summary[c(1,6)]))*1e6, ylab='Interpulse interval range\n(microsec)')
abline(h=0.5)

plot(sapply(res, function(x) x$PW.summary[3])*1e6, ylab='Median pulse width\n(microsec)', log='y')
abline(h=2*unique(paramMat$dur0), col='red')
plot(sapply(res, function(x) x$PW.sd)*1e6, ylab='Pulse width stdev\n(microsec)')
abline(h=0.5)
plot(sapply(res, function(x) diff(x$PW.summary[c(1,6)]))*1e6, ylab='Pulse width range\n(microsec)')
abline(h=0.5)

plot(sapply(res, function(x) x$sh.median), ylab='Median pos. pulse amplitude (V)')
plot(sapply(res, function(x) x$sh.sd), ylab='Pulse amplitude sd (V)')
abline(h=0.5)
plot(1,1)

plot(sapply(res, function(x) x$sl.median), ylab='Median neg. pulse amplitude (V)')
plot(sapply(res, function(x) x$sl.sd), ylab='Pulse amplitude sd (V)')
abline(h=0.5)
plot(1,1)


```


```{r fuckit}

par(mfrow=c(3,3), mar=c(0,0,0,0))
for (i in 1:10){#(length(res)/2)){
  plot(rowMeans(res[[2*i-1]]$pulseMat), type='l', col='black', axes=FALSE, lty=1)
  lines(rowMeans(res[[2*i]]$pulseMat), type='l', col='red', lty=1)
}
```
## Microstim is digital and highly configurable


## Microstim is better than everything else
  - TABLE 1 comparing stimulators?
    - STG3000 / 4000 from multichannel systems
    - WPI A310 Accupulser?
    - pulsepal
    
## Microstim limitations

## Potential applications
  
  - in vivo stimulation

## Supplemental materials
  - BOM
  - gerbers
  - schematic
  - link to bitbucket
  


  